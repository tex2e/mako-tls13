
TLS 1.3 をフルスクラッチするために役立つことを書きたい。
最終的には「n日でできる! TLS1.3自作入門」みたいな形にしたい。

モチベーション：

- TLS 1.3 を Python で実装できる
  - 鍵共有の仕組みや安全性が理解できる
  - 認証付き暗号が理解できる
  - 公開鍵基盤の仕組みが理解できる
- 以下はおまけ的な要素
  - RFCの読み方
  - SSL/TLS の歴史や攻撃手法

目次：

- Pythonでソケット通信
- プロトコルのデータ構造をオブジェクト化する (ClientHello, ServerHello など)
- データ構造とバイト列の相互変換
- DH鍵共有
- 暗号化
  - AES_128_GCM
  - AES_256_GCM
  - CHACHA20_POLY1305
- curlによる TLS 1.3 のテスト

参考文献：

- [RFC 8446 - The Transport Layer Security (TLS) Protocol Version 1.3](https://tools.ietf.org/html/rfc8446)
- [SSL and TLS Deployment Best Practices](https://github.com/ssllabs/research/wiki/SSL-and-TLS-Deployment-Best-Practices)
- [Qualys SSL Labs - SSL Pulse](https://www.ssllabs.com/ssl-pulse/)

--------------------

## はじめに

インターネットの前身であるARPANETが設計された当時はネットに接続する参加者は大学関係者と限られていたので、性善説に基づいて通信路を暗号化する必要はありませんでした。しかし、誰もがインターネットに参加する現代では、悪意のある人やプロバイダが飛び交うパケットを捕らえて通信内容を調べるかもしれません (郵便はがきと同じです)。通信内容から個人情報やパスワード、クレジットカード番号などを収集されては、安心してインターネットを利用することはできません。この問題をトランスポート層で解決するのがTLS (Transport Layer Security) です。

### TLS

TLS は安全な通信路を作る上で次の特性を持ちます。

- 認証 : 通信の参加者は認証される特性 (サーバ証明書などによる証明)
- 機密性 : 権限を持つ人だけが通信内容にアクセスできる特性 (通信内容の暗号化)
- 完全性 : 改竄されることなく正確な状態を保つ特性 (ハッシュによる改ざん検知)

また、TLSのプロトコルは主に2つの部分から構成されます。

- ハンドシェイクプロトコル : 使用するTLSのバージョンや暗号の種類などを決め、鍵共有を行います。
- レコードプロトコル : ハンドシェイクプロトコルで得られた共有鍵を用いて通信を暗号化します。

### TLS 1.2との違い

TLS 1.3はTLS 1.2と比較したときの主な機能の変更点を以下に示します。

- ハンドシェイクの通信回数が減少 (2-RTT ⇒ 1-RTT)
- 暗号アルゴリズムは認証付き暗号 AEAD だけとなる (暗号文の改ざんが検知可能となる ＆ 互換性用の安全でないアルゴリズムの削除)
- ClientHelloとServerHelloで鍵共有した後のハンドシェイクは全て暗号化
- 鍵導出関数の変更 (PRF ⇒ HKDF)


## プロトコル

この章では TLS 1.3 について説明し、Pythonを使って実装していきます。

### WiresharkでTLS 1.3を観察する
